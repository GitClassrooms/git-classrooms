// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gitlab.hs-flensburg.de/gitlab-classroom/model/database"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newAssignment(db *gorm.DB, opts ...gen.DOOption) assignment {
	_assignment := assignment{}

	_assignment.assignmentDo.UseDB(db, opts...)
	_assignment.assignmentDo.UseModel(&database.Assignment{})

	tableName := _assignment.assignmentDo.TableName()
	_assignment.ALL = field.NewAsterisk(tableName)
	_assignment.ID = field.NewField(tableName, "id")
	_assignment.CreatedAt = field.NewTime(tableName, "created_at")
	_assignment.UpdatedAt = field.NewTime(tableName, "updated_at")
	_assignment.DeletedAt = field.NewField(tableName, "deleted_at")
	_assignment.ClassroomID = field.NewField(tableName, "classroom_id")
	_assignment.TemplateProjectID = field.NewInt(tableName, "template_project_id")
	_assignment.Name = field.NewString(tableName, "name")
	_assignment.Description = field.NewString(tableName, "description")
	_assignment.DueDate = field.NewTime(tableName, "due_date")
	_assignment.Projects = assignmentHasManyProjects{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Projects", "database.AssignmentProjects"),
		Assignment: struct {
			field.RelationField
			Classroom struct {
				field.RelationField
				Owner struct {
					field.RelationField
					OwnedClassrooms struct {
						field.RelationField
					}
					Classrooms struct {
						field.RelationField
						User struct {
							field.RelationField
						}
						Classroom struct {
							field.RelationField
						}
					}
					AssignmentRepositories struct {
						field.RelationField
					}
				}
				Member struct {
					field.RelationField
				}
				Assignments struct {
					field.RelationField
				}
				Invitations struct {
					field.RelationField
					Classroom struct {
						field.RelationField
					}
				}
			}
			Projects struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Projects.Assignment", "database.Assignment"),
			Classroom: struct {
				field.RelationField
				Owner struct {
					field.RelationField
					OwnedClassrooms struct {
						field.RelationField
					}
					Classrooms struct {
						field.RelationField
						User struct {
							field.RelationField
						}
						Classroom struct {
							field.RelationField
						}
					}
					AssignmentRepositories struct {
						field.RelationField
					}
				}
				Member struct {
					field.RelationField
				}
				Assignments struct {
					field.RelationField
				}
				Invitations struct {
					field.RelationField
					Classroom struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Projects.Assignment.Classroom", "database.Classroom"),
				Owner: struct {
					field.RelationField
					OwnedClassrooms struct {
						field.RelationField
					}
					Classrooms struct {
						field.RelationField
						User struct {
							field.RelationField
						}
						Classroom struct {
							field.RelationField
						}
					}
					AssignmentRepositories struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Projects.Assignment.Classroom.Owner", "database.User"),
					OwnedClassrooms: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Projects.Assignment.Classroom.Owner.OwnedClassrooms", "database.Classroom"),
					},
					Classrooms: struct {
						field.RelationField
						User struct {
							field.RelationField
						}
						Classroom struct {
							field.RelationField
						}
					}{
						RelationField: field.NewRelation("Projects.Assignment.Classroom.Owner.Classrooms", "database.UserClassrooms"),
						User: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("Projects.Assignment.Classroom.Owner.Classrooms.User", "database.User"),
						},
						Classroom: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("Projects.Assignment.Classroom.Owner.Classrooms.Classroom", "database.Classroom"),
						},
					},
					AssignmentRepositories: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Projects.Assignment.Classroom.Owner.AssignmentRepositories", "database.AssignmentProjects"),
					},
				},
				Member: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Projects.Assignment.Classroom.Member", "database.UserClassrooms"),
				},
				Assignments: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Projects.Assignment.Classroom.Assignments", "database.Assignment"),
				},
				Invitations: struct {
					field.RelationField
					Classroom struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Projects.Assignment.Classroom.Invitations", "database.ClassroomInvitation"),
					Classroom: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Projects.Assignment.Classroom.Invitations.Classroom", "database.Classroom"),
					},
				},
			},
			Projects: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Projects.Assignment.Projects", "database.AssignmentProjects"),
			},
		},
		User: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Projects.User", "database.User"),
		},
	}

	_assignment.Classroom = assignmentBelongsToClassroom{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Classroom", "database.Classroom"),
	}

	_assignment.fillFieldMap()

	return _assignment
}

type assignment struct {
	assignmentDo

	ALL               field.Asterisk
	ID                field.Field
	CreatedAt         field.Time
	UpdatedAt         field.Time
	DeletedAt         field.Field
	ClassroomID       field.Field
	TemplateProjectID field.Int
	Name              field.String
	Description       field.String
	DueDate           field.Time
	Projects          assignmentHasManyProjects

	Classroom assignmentBelongsToClassroom

	fieldMap map[string]field.Expr
}

func (a assignment) Table(newTableName string) *assignment {
	a.assignmentDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a assignment) As(alias string) *assignment {
	a.assignmentDo.DO = *(a.assignmentDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *assignment) updateTableName(table string) *assignment {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewField(table, "id")
	a.CreatedAt = field.NewTime(table, "created_at")
	a.UpdatedAt = field.NewTime(table, "updated_at")
	a.DeletedAt = field.NewField(table, "deleted_at")
	a.ClassroomID = field.NewField(table, "classroom_id")
	a.TemplateProjectID = field.NewInt(table, "template_project_id")
	a.Name = field.NewString(table, "name")
	a.Description = field.NewString(table, "description")
	a.DueDate = field.NewTime(table, "due_date")

	a.fillFieldMap()

	return a
}

func (a *assignment) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *assignment) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 11)
	a.fieldMap["id"] = a.ID
	a.fieldMap["created_at"] = a.CreatedAt
	a.fieldMap["updated_at"] = a.UpdatedAt
	a.fieldMap["deleted_at"] = a.DeletedAt
	a.fieldMap["classroom_id"] = a.ClassroomID
	a.fieldMap["template_project_id"] = a.TemplateProjectID
	a.fieldMap["name"] = a.Name
	a.fieldMap["description"] = a.Description
	a.fieldMap["due_date"] = a.DueDate

}

func (a assignment) clone(db *gorm.DB) assignment {
	a.assignmentDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a assignment) replaceDB(db *gorm.DB) assignment {
	a.assignmentDo.ReplaceDB(db)
	return a
}

type assignmentHasManyProjects struct {
	db *gorm.DB

	field.RelationField

	Assignment struct {
		field.RelationField
		Classroom struct {
			field.RelationField
			Owner struct {
				field.RelationField
				OwnedClassrooms struct {
					field.RelationField
				}
				Classrooms struct {
					field.RelationField
					User struct {
						field.RelationField
					}
					Classroom struct {
						field.RelationField
					}
				}
				AssignmentRepositories struct {
					field.RelationField
				}
			}
			Member struct {
				field.RelationField
			}
			Assignments struct {
				field.RelationField
			}
			Invitations struct {
				field.RelationField
				Classroom struct {
					field.RelationField
				}
			}
		}
		Projects struct {
			field.RelationField
		}
	}
	User struct {
		field.RelationField
	}
}

func (a assignmentHasManyProjects) Where(conds ...field.Expr) *assignmentHasManyProjects {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a assignmentHasManyProjects) WithContext(ctx context.Context) *assignmentHasManyProjects {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a assignmentHasManyProjects) Session(session *gorm.Session) *assignmentHasManyProjects {
	a.db = a.db.Session(session)
	return &a
}

func (a assignmentHasManyProjects) Model(m *database.Assignment) *assignmentHasManyProjectsTx {
	return &assignmentHasManyProjectsTx{a.db.Model(m).Association(a.Name())}
}

type assignmentHasManyProjectsTx struct{ tx *gorm.Association }

func (a assignmentHasManyProjectsTx) Find() (result []*database.AssignmentProjects, err error) {
	return result, a.tx.Find(&result)
}

func (a assignmentHasManyProjectsTx) Append(values ...*database.AssignmentProjects) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a assignmentHasManyProjectsTx) Replace(values ...*database.AssignmentProjects) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a assignmentHasManyProjectsTx) Delete(values ...*database.AssignmentProjects) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a assignmentHasManyProjectsTx) Clear() error {
	return a.tx.Clear()
}

func (a assignmentHasManyProjectsTx) Count() int64 {
	return a.tx.Count()
}

type assignmentBelongsToClassroom struct {
	db *gorm.DB

	field.RelationField
}

func (a assignmentBelongsToClassroom) Where(conds ...field.Expr) *assignmentBelongsToClassroom {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a assignmentBelongsToClassroom) WithContext(ctx context.Context) *assignmentBelongsToClassroom {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a assignmentBelongsToClassroom) Session(session *gorm.Session) *assignmentBelongsToClassroom {
	a.db = a.db.Session(session)
	return &a
}

func (a assignmentBelongsToClassroom) Model(m *database.Assignment) *assignmentBelongsToClassroomTx {
	return &assignmentBelongsToClassroomTx{a.db.Model(m).Association(a.Name())}
}

type assignmentBelongsToClassroomTx struct{ tx *gorm.Association }

func (a assignmentBelongsToClassroomTx) Find() (result *database.Classroom, err error) {
	return result, a.tx.Find(&result)
}

func (a assignmentBelongsToClassroomTx) Append(values ...*database.Classroom) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a assignmentBelongsToClassroomTx) Replace(values ...*database.Classroom) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a assignmentBelongsToClassroomTx) Delete(values ...*database.Classroom) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a assignmentBelongsToClassroomTx) Clear() error {
	return a.tx.Clear()
}

func (a assignmentBelongsToClassroomTx) Count() int64 {
	return a.tx.Count()
}

type assignmentDo struct{ gen.DO }

type IAssignmentDo interface {
	gen.SubQuery
	Debug() IAssignmentDo
	WithContext(ctx context.Context) IAssignmentDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAssignmentDo
	WriteDB() IAssignmentDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAssignmentDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAssignmentDo
	Not(conds ...gen.Condition) IAssignmentDo
	Or(conds ...gen.Condition) IAssignmentDo
	Select(conds ...field.Expr) IAssignmentDo
	Where(conds ...gen.Condition) IAssignmentDo
	Order(conds ...field.Expr) IAssignmentDo
	Distinct(cols ...field.Expr) IAssignmentDo
	Omit(cols ...field.Expr) IAssignmentDo
	Join(table schema.Tabler, on ...field.Expr) IAssignmentDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAssignmentDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAssignmentDo
	Group(cols ...field.Expr) IAssignmentDo
	Having(conds ...gen.Condition) IAssignmentDo
	Limit(limit int) IAssignmentDo
	Offset(offset int) IAssignmentDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAssignmentDo
	Unscoped() IAssignmentDo
	Create(values ...*database.Assignment) error
	CreateInBatches(values []*database.Assignment, batchSize int) error
	Save(values ...*database.Assignment) error
	First() (*database.Assignment, error)
	Take() (*database.Assignment, error)
	Last() (*database.Assignment, error)
	Find() ([]*database.Assignment, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*database.Assignment, err error)
	FindInBatches(result *[]*database.Assignment, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*database.Assignment) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAssignmentDo
	Assign(attrs ...field.AssignExpr) IAssignmentDo
	Joins(fields ...field.RelationField) IAssignmentDo
	Preload(fields ...field.RelationField) IAssignmentDo
	FirstOrInit() (*database.Assignment, error)
	FirstOrCreate() (*database.Assignment, error)
	FindByPage(offset int, limit int) (result []*database.Assignment, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAssignmentDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a assignmentDo) Debug() IAssignmentDo {
	return a.withDO(a.DO.Debug())
}

func (a assignmentDo) WithContext(ctx context.Context) IAssignmentDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a assignmentDo) ReadDB() IAssignmentDo {
	return a.Clauses(dbresolver.Read)
}

func (a assignmentDo) WriteDB() IAssignmentDo {
	return a.Clauses(dbresolver.Write)
}

func (a assignmentDo) Session(config *gorm.Session) IAssignmentDo {
	return a.withDO(a.DO.Session(config))
}

func (a assignmentDo) Clauses(conds ...clause.Expression) IAssignmentDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a assignmentDo) Returning(value interface{}, columns ...string) IAssignmentDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a assignmentDo) Not(conds ...gen.Condition) IAssignmentDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a assignmentDo) Or(conds ...gen.Condition) IAssignmentDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a assignmentDo) Select(conds ...field.Expr) IAssignmentDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a assignmentDo) Where(conds ...gen.Condition) IAssignmentDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a assignmentDo) Order(conds ...field.Expr) IAssignmentDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a assignmentDo) Distinct(cols ...field.Expr) IAssignmentDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a assignmentDo) Omit(cols ...field.Expr) IAssignmentDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a assignmentDo) Join(table schema.Tabler, on ...field.Expr) IAssignmentDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a assignmentDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAssignmentDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a assignmentDo) RightJoin(table schema.Tabler, on ...field.Expr) IAssignmentDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a assignmentDo) Group(cols ...field.Expr) IAssignmentDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a assignmentDo) Having(conds ...gen.Condition) IAssignmentDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a assignmentDo) Limit(limit int) IAssignmentDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a assignmentDo) Offset(offset int) IAssignmentDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a assignmentDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAssignmentDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a assignmentDo) Unscoped() IAssignmentDo {
	return a.withDO(a.DO.Unscoped())
}

func (a assignmentDo) Create(values ...*database.Assignment) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a assignmentDo) CreateInBatches(values []*database.Assignment, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a assignmentDo) Save(values ...*database.Assignment) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a assignmentDo) First() (*database.Assignment, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*database.Assignment), nil
	}
}

func (a assignmentDo) Take() (*database.Assignment, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*database.Assignment), nil
	}
}

func (a assignmentDo) Last() (*database.Assignment, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*database.Assignment), nil
	}
}

func (a assignmentDo) Find() ([]*database.Assignment, error) {
	result, err := a.DO.Find()
	return result.([]*database.Assignment), err
}

func (a assignmentDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*database.Assignment, err error) {
	buf := make([]*database.Assignment, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a assignmentDo) FindInBatches(result *[]*database.Assignment, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a assignmentDo) Attrs(attrs ...field.AssignExpr) IAssignmentDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a assignmentDo) Assign(attrs ...field.AssignExpr) IAssignmentDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a assignmentDo) Joins(fields ...field.RelationField) IAssignmentDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a assignmentDo) Preload(fields ...field.RelationField) IAssignmentDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a assignmentDo) FirstOrInit() (*database.Assignment, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*database.Assignment), nil
	}
}

func (a assignmentDo) FirstOrCreate() (*database.Assignment, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*database.Assignment), nil
	}
}

func (a assignmentDo) FindByPage(offset int, limit int) (result []*database.Assignment, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a assignmentDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a assignmentDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a assignmentDo) Delete(models ...*database.Assignment) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *assignmentDo) withDO(do gen.Dao) *assignmentDo {
	a.DO = *do.(*gen.DO)
	return a
}

// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gitlab.hs-flensburg.de/gitlab-classroom/model/database"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newClassroomInvitation(db *gorm.DB, opts ...gen.DOOption) classroomInvitation {
	_classroomInvitation := classroomInvitation{}

	_classroomInvitation.classroomInvitationDo.UseDB(db, opts...)
	_classroomInvitation.classroomInvitationDo.UseModel(&database.ClassroomInvitation{})

	tableName := _classroomInvitation.classroomInvitationDo.TableName()
	_classroomInvitation.ALL = field.NewAsterisk(tableName)
	_classroomInvitation.ID = field.NewField(tableName, "id")
	_classroomInvitation.CreatedAt = field.NewTime(tableName, "created_at")
	_classroomInvitation.UpdatedAt = field.NewTime(tableName, "updated_at")
	_classroomInvitation.Status = field.NewUint8(tableName, "status")
	_classroomInvitation.ClassroomID = field.NewField(tableName, "classroom_id")
	_classroomInvitation.Email = field.NewString(tableName, "email")
	_classroomInvitation.Enabled = field.NewBool(tableName, "enabled")
	_classroomInvitation.ExpiryDate = field.NewTime(tableName, "expiry_date")
	_classroomInvitation.Classroom = classroomInvitationBelongsToClassroom{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Classroom", "database.Classroom"),
		Owner: struct {
			field.RelationField
			OwnedClassrooms struct {
				field.RelationField
			}
			Classrooms struct {
				field.RelationField
				User struct {
					field.RelationField
				}
				Classroom struct {
					field.RelationField
				}
			}
			AssignmentRepositories struct {
				field.RelationField
				Assignment struct {
					field.RelationField
					Classroom struct {
						field.RelationField
					}
					Projects struct {
						field.RelationField
					}
				}
				User struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("Classroom.Owner", "database.User"),
			OwnedClassrooms: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Classroom.Owner.OwnedClassrooms", "database.Classroom"),
			},
			Classrooms: struct {
				field.RelationField
				User struct {
					field.RelationField
				}
				Classroom struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Classroom.Owner.Classrooms", "database.UserClassrooms"),
				User: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Classroom.Owner.Classrooms.User", "database.User"),
				},
				Classroom: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Classroom.Owner.Classrooms.Classroom", "database.Classroom"),
				},
			},
			AssignmentRepositories: struct {
				field.RelationField
				Assignment struct {
					field.RelationField
					Classroom struct {
						field.RelationField
					}
					Projects struct {
						field.RelationField
					}
				}
				User struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Classroom.Owner.AssignmentRepositories", "database.AssignmentProjects"),
				Assignment: struct {
					field.RelationField
					Classroom struct {
						field.RelationField
					}
					Projects struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Classroom.Owner.AssignmentRepositories.Assignment", "database.Assignment"),
					Classroom: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Classroom.Owner.AssignmentRepositories.Assignment.Classroom", "database.Classroom"),
					},
					Projects: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Classroom.Owner.AssignmentRepositories.Assignment.Projects", "database.AssignmentProjects"),
					},
				},
				User: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Classroom.Owner.AssignmentRepositories.User", "database.User"),
				},
			},
		},
		Member: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Classroom.Member", "database.UserClassrooms"),
		},
		Assignments: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Classroom.Assignments", "database.Assignment"),
		},
		Invitations: struct {
			field.RelationField
			Classroom struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Classroom.Invitations", "database.ClassroomInvitation"),
			Classroom: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Classroom.Invitations.Classroom", "database.Classroom"),
			},
		},
	}

	_classroomInvitation.fillFieldMap()

	return _classroomInvitation
}

type classroomInvitation struct {
	classroomInvitationDo

	ALL         field.Asterisk
	ID          field.Field
	CreatedAt   field.Time
	UpdatedAt   field.Time
	Status      field.Uint8
	ClassroomID field.Field
	Email       field.String
	Enabled     field.Bool
	ExpiryDate  field.Time
	Classroom   classroomInvitationBelongsToClassroom

	fieldMap map[string]field.Expr
}

func (c classroomInvitation) Table(newTableName string) *classroomInvitation {
	c.classroomInvitationDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c classroomInvitation) As(alias string) *classroomInvitation {
	c.classroomInvitationDo.DO = *(c.classroomInvitationDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *classroomInvitation) updateTableName(table string) *classroomInvitation {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewField(table, "id")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.Status = field.NewUint8(table, "status")
	c.ClassroomID = field.NewField(table, "classroom_id")
	c.Email = field.NewString(table, "email")
	c.Enabled = field.NewBool(table, "enabled")
	c.ExpiryDate = field.NewTime(table, "expiry_date")

	c.fillFieldMap()

	return c
}

func (c *classroomInvitation) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *classroomInvitation) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 9)
	c.fieldMap["id"] = c.ID
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["status"] = c.Status
	c.fieldMap["classroom_id"] = c.ClassroomID
	c.fieldMap["email"] = c.Email
	c.fieldMap["enabled"] = c.Enabled
	c.fieldMap["expiry_date"] = c.ExpiryDate

}

func (c classroomInvitation) clone(db *gorm.DB) classroomInvitation {
	c.classroomInvitationDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c classroomInvitation) replaceDB(db *gorm.DB) classroomInvitation {
	c.classroomInvitationDo.ReplaceDB(db)
	return c
}

type classroomInvitationBelongsToClassroom struct {
	db *gorm.DB

	field.RelationField

	Owner struct {
		field.RelationField
		OwnedClassrooms struct {
			field.RelationField
		}
		Classrooms struct {
			field.RelationField
			User struct {
				field.RelationField
			}
			Classroom struct {
				field.RelationField
			}
		}
		AssignmentRepositories struct {
			field.RelationField
			Assignment struct {
				field.RelationField
				Classroom struct {
					field.RelationField
				}
				Projects struct {
					field.RelationField
				}
			}
			User struct {
				field.RelationField
			}
		}
	}
	Member struct {
		field.RelationField
	}
	Assignments struct {
		field.RelationField
	}
	Invitations struct {
		field.RelationField
		Classroom struct {
			field.RelationField
		}
	}
}

func (a classroomInvitationBelongsToClassroom) Where(conds ...field.Expr) *classroomInvitationBelongsToClassroom {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a classroomInvitationBelongsToClassroom) WithContext(ctx context.Context) *classroomInvitationBelongsToClassroom {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a classroomInvitationBelongsToClassroom) Session(session *gorm.Session) *classroomInvitationBelongsToClassroom {
	a.db = a.db.Session(session)
	return &a
}

func (a classroomInvitationBelongsToClassroom) Model(m *database.ClassroomInvitation) *classroomInvitationBelongsToClassroomTx {
	return &classroomInvitationBelongsToClassroomTx{a.db.Model(m).Association(a.Name())}
}

type classroomInvitationBelongsToClassroomTx struct{ tx *gorm.Association }

func (a classroomInvitationBelongsToClassroomTx) Find() (result *database.Classroom, err error) {
	return result, a.tx.Find(&result)
}

func (a classroomInvitationBelongsToClassroomTx) Append(values ...*database.Classroom) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a classroomInvitationBelongsToClassroomTx) Replace(values ...*database.Classroom) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a classroomInvitationBelongsToClassroomTx) Delete(values ...*database.Classroom) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a classroomInvitationBelongsToClassroomTx) Clear() error {
	return a.tx.Clear()
}

func (a classroomInvitationBelongsToClassroomTx) Count() int64 {
	return a.tx.Count()
}

type classroomInvitationDo struct{ gen.DO }

type IClassroomInvitationDo interface {
	gen.SubQuery
	Debug() IClassroomInvitationDo
	WithContext(ctx context.Context) IClassroomInvitationDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IClassroomInvitationDo
	WriteDB() IClassroomInvitationDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IClassroomInvitationDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IClassroomInvitationDo
	Not(conds ...gen.Condition) IClassroomInvitationDo
	Or(conds ...gen.Condition) IClassroomInvitationDo
	Select(conds ...field.Expr) IClassroomInvitationDo
	Where(conds ...gen.Condition) IClassroomInvitationDo
	Order(conds ...field.Expr) IClassroomInvitationDo
	Distinct(cols ...field.Expr) IClassroomInvitationDo
	Omit(cols ...field.Expr) IClassroomInvitationDo
	Join(table schema.Tabler, on ...field.Expr) IClassroomInvitationDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IClassroomInvitationDo
	RightJoin(table schema.Tabler, on ...field.Expr) IClassroomInvitationDo
	Group(cols ...field.Expr) IClassroomInvitationDo
	Having(conds ...gen.Condition) IClassroomInvitationDo
	Limit(limit int) IClassroomInvitationDo
	Offset(offset int) IClassroomInvitationDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IClassroomInvitationDo
	Unscoped() IClassroomInvitationDo
	Create(values ...*database.ClassroomInvitation) error
	CreateInBatches(values []*database.ClassroomInvitation, batchSize int) error
	Save(values ...*database.ClassroomInvitation) error
	First() (*database.ClassroomInvitation, error)
	Take() (*database.ClassroomInvitation, error)
	Last() (*database.ClassroomInvitation, error)
	Find() ([]*database.ClassroomInvitation, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*database.ClassroomInvitation, err error)
	FindInBatches(result *[]*database.ClassroomInvitation, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*database.ClassroomInvitation) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IClassroomInvitationDo
	Assign(attrs ...field.AssignExpr) IClassroomInvitationDo
	Joins(fields ...field.RelationField) IClassroomInvitationDo
	Preload(fields ...field.RelationField) IClassroomInvitationDo
	FirstOrInit() (*database.ClassroomInvitation, error)
	FirstOrCreate() (*database.ClassroomInvitation, error)
	FindByPage(offset int, limit int) (result []*database.ClassroomInvitation, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IClassroomInvitationDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c classroomInvitationDo) Debug() IClassroomInvitationDo {
	return c.withDO(c.DO.Debug())
}

func (c classroomInvitationDo) WithContext(ctx context.Context) IClassroomInvitationDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c classroomInvitationDo) ReadDB() IClassroomInvitationDo {
	return c.Clauses(dbresolver.Read)
}

func (c classroomInvitationDo) WriteDB() IClassroomInvitationDo {
	return c.Clauses(dbresolver.Write)
}

func (c classroomInvitationDo) Session(config *gorm.Session) IClassroomInvitationDo {
	return c.withDO(c.DO.Session(config))
}

func (c classroomInvitationDo) Clauses(conds ...clause.Expression) IClassroomInvitationDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c classroomInvitationDo) Returning(value interface{}, columns ...string) IClassroomInvitationDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c classroomInvitationDo) Not(conds ...gen.Condition) IClassroomInvitationDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c classroomInvitationDo) Or(conds ...gen.Condition) IClassroomInvitationDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c classroomInvitationDo) Select(conds ...field.Expr) IClassroomInvitationDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c classroomInvitationDo) Where(conds ...gen.Condition) IClassroomInvitationDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c classroomInvitationDo) Order(conds ...field.Expr) IClassroomInvitationDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c classroomInvitationDo) Distinct(cols ...field.Expr) IClassroomInvitationDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c classroomInvitationDo) Omit(cols ...field.Expr) IClassroomInvitationDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c classroomInvitationDo) Join(table schema.Tabler, on ...field.Expr) IClassroomInvitationDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c classroomInvitationDo) LeftJoin(table schema.Tabler, on ...field.Expr) IClassroomInvitationDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c classroomInvitationDo) RightJoin(table schema.Tabler, on ...field.Expr) IClassroomInvitationDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c classroomInvitationDo) Group(cols ...field.Expr) IClassroomInvitationDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c classroomInvitationDo) Having(conds ...gen.Condition) IClassroomInvitationDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c classroomInvitationDo) Limit(limit int) IClassroomInvitationDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c classroomInvitationDo) Offset(offset int) IClassroomInvitationDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c classroomInvitationDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IClassroomInvitationDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c classroomInvitationDo) Unscoped() IClassroomInvitationDo {
	return c.withDO(c.DO.Unscoped())
}

func (c classroomInvitationDo) Create(values ...*database.ClassroomInvitation) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c classroomInvitationDo) CreateInBatches(values []*database.ClassroomInvitation, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c classroomInvitationDo) Save(values ...*database.ClassroomInvitation) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c classroomInvitationDo) First() (*database.ClassroomInvitation, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*database.ClassroomInvitation), nil
	}
}

func (c classroomInvitationDo) Take() (*database.ClassroomInvitation, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*database.ClassroomInvitation), nil
	}
}

func (c classroomInvitationDo) Last() (*database.ClassroomInvitation, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*database.ClassroomInvitation), nil
	}
}

func (c classroomInvitationDo) Find() ([]*database.ClassroomInvitation, error) {
	result, err := c.DO.Find()
	return result.([]*database.ClassroomInvitation), err
}

func (c classroomInvitationDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*database.ClassroomInvitation, err error) {
	buf := make([]*database.ClassroomInvitation, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c classroomInvitationDo) FindInBatches(result *[]*database.ClassroomInvitation, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c classroomInvitationDo) Attrs(attrs ...field.AssignExpr) IClassroomInvitationDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c classroomInvitationDo) Assign(attrs ...field.AssignExpr) IClassroomInvitationDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c classroomInvitationDo) Joins(fields ...field.RelationField) IClassroomInvitationDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c classroomInvitationDo) Preload(fields ...field.RelationField) IClassroomInvitationDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c classroomInvitationDo) FirstOrInit() (*database.ClassroomInvitation, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*database.ClassroomInvitation), nil
	}
}

func (c classroomInvitationDo) FirstOrCreate() (*database.ClassroomInvitation, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*database.ClassroomInvitation), nil
	}
}

func (c classroomInvitationDo) FindByPage(offset int, limit int) (result []*database.ClassroomInvitation, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c classroomInvitationDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c classroomInvitationDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c classroomInvitationDo) Delete(models ...*database.ClassroomInvitation) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *classroomInvitationDo) withDO(do gen.Dao) *classroomInvitationDo {
	c.DO = *do.(*gen.DO)
	return c
}
